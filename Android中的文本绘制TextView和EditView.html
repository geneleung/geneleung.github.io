<!DOCTYPE html>
<html lang="zh_cn">
<head>
        <title>iknockdoor-Android中的文本绘制TextView和EditView</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" type="text/css" href="http://www.iknockdoor.com/theme/css/org.css" />
        <link rel="stylesheet" type="text/css" href="http://www.iknockdoor.com/theme/css/custom.css" />
        <link href="http://www.iknockdoor.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="iknockdoor Full Atom Feed" />

    <meta name="tags" content="Android" />

<script>var _gaq=[['_setAccount','UA-103057848-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script>
        <!-- mathjax config similar to math.stackexchange -->
	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
	  jax: ["input/TeX", "output/HTML-CSS"],
	  tex2jax: {
	  inlineMath: [ ['$', '$'] ],
	  displayMath: [ ['$$', '$$']],
	  processEscapes: true,
	  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
	  },
	  messageStyle: "none",
	  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
	  });
	</script>
</head>

<body id="index" class="home">
  <div id="banner"><div id="banner-inside">
      <nav id="menu">
      <header id="site_name">
                iknockdoor
        </header><!-- /#banner -->
          <ul>
            <li><a href="http://www.iknockdoor.com/index.html">Index</a></li>
            <li><a href="http://www.iknockdoor.com/categories.html">Categories</a></li>
            <li><a href="http://www.iknockdoor.com/tags.html">Tags</a></li>
            <li><a href="http://www.iknockdoor.com/archives.html">Archives</a></li>
      </ul></nav><!-- /#menu -->
  </div></div>
  <div id="content">
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="http://www.iknockdoor.com/Android中的文本绘制TextView和EditView.html" rel="bookmark"
         title="Permalink to Android中的文本绘制TextView和EditView">Android中的文本绘制TextView和EditView</a></h2>
 
  </header>
  <footer class="post-info">
    <time class="published" datetime="2019-08-15T00:00:00+08:00">
      四 15 八月 2019
    </time>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> TextView适合显示多大的数据量？如果需要切割，如何切割是合理的？</h2>
<div class="outline-text-2" id="text-1">
<p>
初步的几个想法：
</p>
<ol class="org-ol">
<li>具体可能没有说多大数据量合适，主要看内存和绘制速度，可以考虑根据手机内存大小，调整这个值
</li>
<li>如何切割这个问题到现在也没有一个明确的解法，一个想法是根据
TextView自己的Layout获取当前屏幕行数，或者根据行高，字体大小，估算出大概一屏是多少字，然后缓冲上下两屏的数据。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 渲染的基本单位是什么？一行？相同span的文字？同一行中不同的span如何处理？</h2>
<div class="outline-text-2" id="text-2">
<p>
看TextLine类，以一个可视行为基本渲染单位。同一行中不同的span如何处理呢？看了一遍源码，不是每个细节的处理都看懂了，但大体思路八九不离十，其实主要是看对TextPaint的理解，TextPaint有什么能力，能绘制什么，能否分段，在TextLine最后绘制的时候里面也有几个循环处理，处理同一行不同的
span的效果，如果一行都是几个span的叠加，效果没有变化，算同一个。比如下划线的处理，TextLine是找出这一行中下划线的位置，然后单独绘制矩形的，可以这么理解TextLine对一行的渲染，分为几个图层，范围相同的span尽量一起绘制，如果无法一起绘制就根据span的类型和效果分段绘制。比如下划线是找到下划线位置，绘制矩形底线，再统一绘制文字，而如果给中间一段文字不同的颜色，会分三次绘制文字。
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 到底谁在负责渲染？</h2>
<div class="outline-text-2" id="text-3">
<p>
Layout和TextLine
</p>
<ul class="org-ul">
<li>Layout负责了ParagraphStyle的渲染
</li>
<li>TextLine负责了CharacterStyle的渲染
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 测量布局的相关内容</h2>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> EditText是如何修改内容的并通知监听者的，总不能不停的setText吧</h2>
<div class="outline-text-2" id="text-5">
<p>
2019.10.10 18:00
其实当时已经基本上搞清楚是如何修改和更新内容的了，但是当时没有记录。参考当时的笔记现在补充上来。
</p>

<ul class="org-ul">
<li>TextView -&gt; setText
<ul class="org-ul">
<li>Editable t = mEditableFactory.newE&#x2026;
</li>
<li>mText = t
</li>
</ul>
</li>
<li>TextView -&gt; onCreateInputConnection
<ul class="org-ul">
<li>EditableInputConnection -&gt; getEditable
</li>
</ul>
</li>
<li>上面两步关联了SpanableStringBuilder
</li>
<li>SpanableStringBuilder -&gt; replace方法通过监听者通知DynamicLayout -&gt; reflow
</li>
<li>DynamicLayout在generate时设置了监听者
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 文本体系的整体设计</h2>
<div class="outline-text-2" id="text-6">
<p>
整个span文本体系可以分为几大部分，一个是可span的字符串，一个是span样式，一个是对span文本到span结构的解析。
</p>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> span的存储结构</h3>
<div class="outline-text-3" id="text-6-1">
<p>
在SpannableStringInternal的实现中可以看到span是如何存储的。
</p>
<ul class="org-ul">
<li>int mSpanCount 有几个span
</li>
<li>Object[] mSpans span的数组，数组的长度与mSpanCount对应
</li>
<li>int[] mSpanData 保存span数据的数组，一个span会有三个数局，起点，重点，以及flag(标示如何处理起点和终点),因此这个数组有一点特殊，他的长度是mSpanCount的3倍。
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> span的分类设计</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Main rules:
</p>
<ul class="org-ul">
<li>if a Span affects character-level text formatting, it extends
CharacterStyle.
</li>
<li>if a Span affects paragraph-level text formatting, it implements
ParagraphStyle
</li>
<li>if a Span modifies the character-level text appearance, it
implements UpdateAppearance
</li>
<li>if a Span modifies the character-level text metrics|size, it
implements UpdateLayout
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> TextView作为一个Android的view控件三大流程是怎样的？</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> onMeasure和onLayout</h3>
<div class="outline-text-3" id="text-7-1">
<p>
这两个流程放在一起说，不说的很详细，这里主要处理了几个问题：
</p>
<ol class="org-ol">
<li>根据语言，比如是从左到右还是从右到左，以及是否有span等信息选择布局类,BoringLayout,StaticLayout,DynamicLayout
<ul class="org-ul">
<li>BoringLayout 处理单行，从左到右，无span的文本
</li>
<li>StaticLayout 处理不动态变化的富文本
</li>
<li>DynamicLayout 处理动态变化的富文本
</li>
</ul>
</li>
<li>处理Android普遍的view的一些设置，比如padding等
</li>
<li>处理TextView自定义的属性，比如行高，字间距等
</li>
</ol>

<p>
TextView最复杂的部分就是上面三个Layout类了，在Layout的实现类中，处理了纯文本，带span的文本，emoji，图片，并根据文本的样式，比如span的样式处理文本的排版，比如换行。这里面的处理是比较复杂的，但是如果我们不处理布局问题，不需要太纠结细节的实现，总之知道Layout实现的功能即可。
</p>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> onDraw</h3>
<div class="outline-text-3" id="text-7-2">
<p>
重点看一下span文本的绘制过程。从TextView的onDraw方法入手，可以看到最终对于可编辑的TextView是交给Editor处理的，非可编辑的TextView是交给Layout处理的，Layout的三个子类重点区别在于测量和布局，对于绘制这块并没有区别，因此没有覆盖Layout的drawText（）方法，我们直接看
Layout的drawText()方法（其中间还有绘制背景，间距，阴影等，比较容易，也不是重点，直接略过，我们重点考察文字的绘制过程）
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">public</span> <span class="org-type">void</span> <span class="org-function-name">drawText</span>(<span class="org-type">Canvas</span> <span class="org-variable-name">canvas</span>, <span class="org-type">int</span> <span class="org-variable-name">firstLine</span>, <span class="org-type">int</span> <span class="org-variable-name">lastLine</span>) {
     <span class="org-type">int</span> <span class="org-variable-name">previousLineBottom</span> = getLineTop(firstLine);
     <span class="org-type">int</span> <span class="org-variable-name">previousLineEnd</span> = getLineStart(firstLine);
     <span class="org-type">ParagraphStyle</span>[] <span class="org-variable-name">spans</span> = NO_PARA_SPANS;
     <span class="org-type">int</span> <span class="org-variable-name">spanEnd</span> = 0;
     <span class="org-keyword">final</span> <span class="org-type">TextPaint</span> <span class="org-variable-name">paint</span> = mWorkPaint;
     paint.set(mPaint);
     <span class="org-type">CharSequence</span> <span class="org-variable-name">buf</span> = mText;

     <span class="org-type">Alignment</span> <span class="org-variable-name">paraAlign</span> = mAlignment;
     <span class="org-type">TabStops</span> <span class="org-variable-name">tabStops</span> = <span class="org-constant">null</span>;
     <span class="org-type">boolean</span> <span class="org-variable-name">tabStopsIsInitialized</span> = <span class="org-constant">false</span>;

     <span class="org-type">TextLine</span> <span class="org-variable-name">tl</span> = TextLine.obtain();

     <span class="org-comment-delimiter">// </span><span class="org-comment">Draw the lines, one at a time.</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">The baseline is the top of the following line minus the current line's descent.</span>
     <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">lineNum</span> = firstLine; lineNum &lt;= lastLine; lineNum++) {
         <span class="org-type">int</span> <span class="org-variable-name">start</span> = previousLineEnd;
         previousLineEnd = getLineStart(lineNum + 1);
         <span class="org-keyword">final</span> <span class="org-type">boolean</span> <span class="org-variable-name">justify</span> = isJustificationRequired(lineNum);
         <span class="org-type">int</span> <span class="org-variable-name">end</span> = getLineVisibleEnd(lineNum, start, previousLineEnd);
         paint.setHyphenEdit(getHyphen(lineNum));

         <span class="org-type">int</span> <span class="org-variable-name">ltop</span> = previousLineBottom;
         <span class="org-type">int</span> <span class="org-variable-name">lbottom</span> = getLineTop(lineNum + 1);
         previousLineBottom = lbottom;
         <span class="org-type">int</span> <span class="org-variable-name">lbaseline</span> = lbottom - getLineDescent(lineNum);

         <span class="org-type">int</span> <span class="org-variable-name">dir</span> = getParagraphDirection(lineNum);
         <span class="org-type">int</span> <span class="org-variable-name">left</span> = 0;
         <span class="org-type">int</span> <span class="org-variable-name">right</span> = mWidth;

         <span class="org-keyword">if</span> (mSpannedText) {
             <span class="org-type">Spanned</span> <span class="org-variable-name">sp</span> = (<span class="org-type">Spanned</span>) buf;
             <span class="org-type">int</span> <span class="org-variable-name">textLength</span> = buf.length();
             <span class="org-type">boolean</span> <span class="org-variable-name">isFirstParaLine</span> = (start == 0 || buf.charAt(start - 1) == <span class="org-string">'\n'</span>);

             <span class="org-comment-delimiter">// </span><span class="org-comment">New batch of paragraph styles, collect into spans array.</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">Compute the alignment, last alignment style wins.</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">Reset tabStops, we'll rebuild if we encounter a line with</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">tabs.</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">We expect paragraph spans to be relatively infrequent, use</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">spanEnd so that we can check less frequently.  Since</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">paragraph styles ought to apply to entire paragraphs, we can</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">just collect the ones present at the start of the paragraph.</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">If spanEnd is before the end of the paragraph, that's not</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">our problem.</span>
             <span class="org-keyword">if</span> (start &gt;= spanEnd &amp;&amp; (lineNum == firstLine || isFirstParaLine)) {
                 spanEnd = sp.nextSpanTransition(start, textLength,
                                                 ParagraphStyle.<span class="org-keyword">class</span>);
                 spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.<span class="org-keyword">class</span>);

                 paraAlign = mAlignment;
                 <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">n</span> = spans.length - 1; n &gt;= 0; n--) {
                     <span class="org-keyword">if</span> (spans[n] <span class="org-keyword">instanceof</span> AlignmentSpan) {
                         paraAlign = ((<span class="org-type">AlignmentSpan</span>) spans[n]).getAlignment();
                         <span class="org-keyword">break</span>;
                     }
                 }

                 tabStopsIsInitialized = <span class="org-constant">false</span>;
             }

             <span class="org-comment-delimiter">// </span><span class="org-comment">Draw all leading margin spans.  Adjust left or right according</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">to the paragraph direction of the line.</span>
             <span class="org-keyword">final</span> <span class="org-type">int</span> <span class="org-variable-name">length</span> = spans.length;
             <span class="org-type">boolean</span> <span class="org-variable-name">useFirstLineMargin</span> = isFirstParaLine;
             <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">n</span> = 0; n &lt; <span class="org-type">length</span>; n++) {
                 <span class="org-keyword">if</span> (spans[n] <span class="org-keyword">instanceof</span> LeadingMarginSpan2) {
                     <span class="org-type">int</span> <span class="org-variable-name">count</span> = ((<span class="org-type">LeadingMarginSpan2</span>) spans[n]).getLeadingMarginLineCount();
                     <span class="org-type">int</span> <span class="org-variable-name">startLine</span> = getLineForOffset(sp.getSpanStart(spans[n]));
                     <span class="org-comment-delimiter">// </span><span class="org-comment">if there is more than one LeadingMarginSpan2, use</span>
                     <span class="org-comment-delimiter">// </span><span class="org-comment">the count that is greatest</span>
                     <span class="org-keyword">if</span> (lineNum &lt; <span class="org-type">startLine</span> + count) {
                         useFirstLineMargin = <span class="org-constant">true</span>;
                         <span class="org-keyword">break</span>;
                     }
                 }
             }
             <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">n</span> = 0; n &lt; <span class="org-type">length</span>; n++) {
                 <span class="org-keyword">if</span> (spans[n] <span class="org-keyword">instanceof</span> LeadingMarginSpan) {
                     <span class="org-type">LeadingMarginSpan</span> <span class="org-variable-name">margin</span> = (<span class="org-type">LeadingMarginSpan</span>) spans[n];
                     <span class="org-keyword">if</span> (dir == DIR_RIGHT_TO_LEFT) {
                         margin.drawLeadingMargin(canvas, paint, right, dir, ltop,
                                                  lbaseline, lbottom, buf,
                                                  start, end, isFirstParaLine, <span class="org-keyword">this</span>);
                         right -= margin.getLeadingMargin(useFirstLineMargin);
                     } <span class="org-keyword">else</span> {
                         margin.drawLeadingMargin(canvas, paint, left, dir, ltop,
                                                  lbaseline, lbottom, buf,
                                                  start, end, isFirstParaLine, <span class="org-keyword">this</span>);
                         left += margin.getLeadingMargin(useFirstLineMargin);
                     }
                 }
             }
         }

         <span class="org-type">boolean</span> <span class="org-variable-name">hasTab</span> = getLineContainsTab(lineNum);
         <span class="org-comment-delimiter">// </span><span class="org-comment">Can't tell if we have tabs for sure, currently</span>
         <span class="org-keyword">if</span> (hasTab &amp;&amp; <span class="org-negation-char">!</span>tabStopsIsInitialized) {
             <span class="org-keyword">if</span> (tabStops == <span class="org-constant">null</span>) {
                 tabStops = <span class="org-keyword">new</span> <span class="org-type">TabStops</span>(TAB_INCREMENT, spans);
             } <span class="org-keyword">else</span> {
                 tabStops.reset(TAB_INCREMENT, spans);
             }
             tabStopsIsInitialized = <span class="org-constant">true</span>;
         }

         <span class="org-comment-delimiter">// </span><span class="org-comment">Determine whether the line aligns to normal, opposite, or center.</span>
         <span class="org-type">Alignment</span> <span class="org-variable-name">align</span> = paraAlign;
         <span class="org-keyword">if</span> (align == <span class="org-constant">Alignment</span>.ALIGN_LEFT) {
             align = (dir == DIR_LEFT_TO_RIGHT) ?
                 <span class="org-constant">Alignment</span>.ALIGN_NORMAL : <span class="org-constant">Alignment</span>.ALIGN_OPPOSITE;
         } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (align == <span class="org-constant">Alignment</span>.ALIGN_RIGHT) {
             align = (dir == DIR_LEFT_TO_RIGHT) ?
                 <span class="org-constant">Alignment</span>.ALIGN_OPPOSITE : <span class="org-constant">Alignment</span>.ALIGN_NORMAL;
         }

         <span class="org-type">int</span> <span class="org-variable-name">x</span>;
         <span class="org-keyword">final</span> <span class="org-type">int</span> <span class="org-variable-name">indentWidth</span>;
         <span class="org-keyword">if</span> (align == <span class="org-constant">Alignment</span>.ALIGN_NORMAL) {
             <span class="org-keyword">if</span> (dir == DIR_LEFT_TO_RIGHT) {
                 indentWidth = getIndentAdjust(lineNum, <span class="org-constant">Alignment</span>.ALIGN_LEFT);
                 x = left + indentWidth;
             } <span class="org-keyword">else</span> {
                 indentWidth = -getIndentAdjust(lineNum, <span class="org-constant">Alignment</span>.ALIGN_RIGHT);
                 x = right - indentWidth;
             }
         } <span class="org-keyword">else</span> {
             <span class="org-type">int</span> <span class="org-variable-name">max</span> = (<span class="org-type">int</span>)getLineExtent(lineNum, tabStops, <span class="org-constant">false</span>);
             <span class="org-keyword">if</span> (align == <span class="org-constant">Alignment</span>.ALIGN_OPPOSITE) {
                 <span class="org-keyword">if</span> (dir == DIR_LEFT_TO_RIGHT) {
                     indentWidth = -getIndentAdjust(lineNum, <span class="org-constant">Alignment</span>.ALIGN_RIGHT);
                     x = right - max - indentWidth;
                 } <span class="org-keyword">else</span> {
                     indentWidth = getIndentAdjust(lineNum, <span class="org-constant">Alignment</span>.ALIGN_LEFT);
                     x = left - max + indentWidth;
                 }
             } <span class="org-keyword">else</span> { <span class="org-comment-delimiter">// </span><span class="org-comment">Alignment.ALIGN_CENTER</span>
                 indentWidth = getIndentAdjust(lineNum, <span class="org-constant">Alignment</span>.ALIGN_CENTER);
                 max = max &amp; ~1;
                 x = ((right + left - max) &gt;&gt; 1) + indentWidth;
             }
         }

         <span class="org-type">Directions</span> <span class="org-variable-name">directions</span> = getLineDirections(lineNum);
         <span class="org-keyword">if</span> (directions == DIRS_ALL_LEFT_TO_RIGHT &amp;&amp; <span class="org-negation-char">!</span>mSpannedText &amp;&amp; <span class="org-negation-char">!</span>hasTab &amp;&amp; <span class="org-negation-char">!</span>justify) {
             <span class="org-comment-delimiter">// </span><span class="org-comment">XXX: assumes there's nothing additional to be done</span>
             canvas.drawText(buf, start, end, x, lbaseline, paint);
         } <span class="org-keyword">else</span> {
             tl.set(paint, buf, start, end, dir, directions, hasTab, tabStops);
             <span class="org-keyword">if</span> (justify) {
                 tl.justify(right - left - indentWidth);
             }
             tl.draw(canvas, x, ltop, lbaseline, lbottom);
         }
     }

     TextLine.recycle(tl);
 }
</pre>
</div>
<p>
这里可以看到拆行的处理，文本的绘制是一行一行进行的，怎么算是一行？拆行是在layout中已经处理好的，这里只是在使用拆行的信息。代码最后，如果是简单文本的绘制，就直接用canvas绘制了，如果是复杂文本就会调用
TextLine的draw方法绘制了。以下是TextLine绘制的核心代码，再往后就是
canvas的绘制了，尤其是到jni层，会比较通用，和文本处理关系不大了。
</p>

<p>
另外在Layout的draw方法中还处理了ParagraphStyle的span，计算段落间距缩进这些，包括段落样式，是在这里直接绘制的。
</p>
<div class="org-src-container">

<pre class="src src-java"><span class="org-doc">/**</span>
<span class="org-doc">  * Utility function for handling a unidirectional run.  The run must not</span>
<span class="org-doc">  * contain tabs but can contain styles.</span>
<span class="org-doc">  *</span>
<span class="org-doc">  *</span>
<span class="org-doc">  * </span><span class="org-doc"><span class="org-constant">@param</span></span><span class="org-doc"> start the line-relative start of the run</span>
<span class="org-doc">  * </span><span class="org-doc"><span class="org-constant">@param</span></span><span class="org-doc"> measureLimit the offset to measure to, between start and limit inclusive</span>
<span class="org-doc">  * </span><span class="org-doc"><span class="org-constant">@param</span></span><span class="org-doc"> limit the limit of the run</span>
<span class="org-doc">  * </span><span class="org-doc"><span class="org-constant">@param</span></span><span class="org-doc"> runIsRtl true if the run is right-to-left</span>
<span class="org-doc">  * </span><span class="org-doc"><span class="org-constant">@param</span></span><span class="org-doc"> c the canvas, can be null</span>
<span class="org-doc">  * </span><span class="org-doc"><span class="org-constant">@param</span></span><span class="org-doc"> x the end of the run closest to the leading margin</span>
<span class="org-doc">  * </span><span class="org-doc"><span class="org-constant">@param</span></span><span class="org-doc"> top the top of the line</span>
<span class="org-doc">  * </span><span class="org-doc"><span class="org-constant">@param</span></span><span class="org-doc"> y the baseline</span>
<span class="org-doc">  * </span><span class="org-doc"><span class="org-constant">@param</span></span><span class="org-doc"> bottom the bottom of the line</span>
<span class="org-doc">  * </span><span class="org-doc"><span class="org-constant">@param</span></span><span class="org-doc"> fmi receives metrics information, can be null</span>
<span class="org-doc">  * </span><span class="org-doc"><span class="org-constant">@param</span></span><span class="org-doc"> needWidth true if the width is required</span>
<span class="org-doc">  * </span><span class="org-doc"><span class="org-constant">@return</span></span><span class="org-doc"> the signed width of the run based on the run direction; only</span>
<span class="org-doc">  * valid if needWidth is true</span>
<span class="org-doc">  */</span>
 <span class="org-keyword">private</span> <span class="org-type">float</span> <span class="org-function-name">handleRun</span>(<span class="org-type">int</span> <span class="org-variable-name">start</span>, <span class="org-type">int</span> <span class="org-variable-name">measureLimit</span>,
         <span class="org-type">int</span> <span class="org-variable-name">limit</span>, <span class="org-type">boolean</span> <span class="org-variable-name">runIsRtl</span>, <span class="org-type">Canvas</span> <span class="org-variable-name">c</span>, <span class="org-type">float</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">top</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span>,
         <span class="org-type">int</span> <span class="org-variable-name">bottom</span>, <span class="org-type">FontMetricsInt</span> <span class="org-variable-name">fmi</span>, <span class="org-type">boolean</span> <span class="org-variable-name">needWidth</span>) {

     <span class="org-keyword">if</span> (measureLimit &lt; <span class="org-type">start</span> || measureLimit &gt; limit) {
         <span class="org-keyword">throw</span> <span class="org-keyword">new</span> <span class="org-type">IndexOutOfBoundsException</span>(<span class="org-string">"measureLimit ("</span> + measureLimit + <span class="org-string">") is out of "</span>
                 + <span class="org-string">"start ("</span> + start + <span class="org-string">") and limit ("</span> + limit + <span class="org-string">") bounds"</span>);
     }

     <span class="org-comment-delimiter">// </span><span class="org-comment">Case of an empty line, make sure we update fmi according to mPaint</span>
     <span class="org-keyword">if</span> (start == measureLimit) {
         <span class="org-keyword">final</span> <span class="org-type">TextPaint</span> <span class="org-variable-name">wp</span> = mWorkPaint;
         wp.set(mPaint);
         <span class="org-keyword">if</span> (fmi != <span class="org-constant">null</span>) {
             expandMetricsFromPaint(fmi, wp);
         }
         <span class="org-keyword">return</span> 0f;
     }

     <span class="org-keyword">final</span> <span class="org-type">boolean</span> <span class="org-variable-name">needsSpanMeasurement</span>;
     <span class="org-keyword">if</span> (mSpanned == <span class="org-constant">null</span>) {
         needsSpanMeasurement = <span class="org-constant">false</span>;
     } <span class="org-keyword">else</span> {
         mMetricAffectingSpanSpanSet.init(mSpanned, mStart + start, mStart + limit);
         mCharacterStyleSpanSet.init(mSpanned, mStart + start, mStart + limit);
         needsSpanMeasurement = mMetricAffectingSpanSpanSet.numberOfSpans != 0
                 || mCharacterStyleSpanSet.numberOfSpans != 0;
     }

     <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>needsSpanMeasurement) {
         <span class="org-keyword">final</span> <span class="org-type">TextPaint</span> <span class="org-variable-name">wp</span> = mWorkPaint;
         wp.set(mPaint);
         wp.setHyphenEdit(adjustHyphenEdit(start, limit, wp.getHyphenEdit()));
         <span class="org-keyword">return</span> handleText(wp, start, limit, start, limit, runIsRtl, c, x, top,
                 y, bottom, fmi, needWidth, measureLimit, <span class="org-constant">null</span>);
     }

     <span class="org-comment-delimiter">// </span><span class="org-comment">Shaping needs to take into account context up to metric boundaries,</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">but rendering needs to take into account character style boundaries.</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">So we iterate through metric runs to get metric bounds,</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">then within each metric run iterate through character style runs</span>
     <span class="org-comment-delimiter">// </span><span class="org-comment">for the run bounds.</span>
     <span class="org-keyword">final</span> <span class="org-type">float</span> <span class="org-variable-name">originalX</span> = x;
     <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = start, <span class="org-variable-name">inext</span>; i &lt; <span class="org-type">measureLimit</span>; i = inext) {
         <span class="org-keyword">final</span> <span class="org-type">TextPaint</span> <span class="org-variable-name">wp</span> = mWorkPaint;
         wp.set(mPaint);

         inext = mMetricAffectingSpanSpanSet.getNextTransition(mStart + i, mStart + limit) -
                 mStart;
         <span class="org-type">int</span> <span class="org-variable-name">mlimit</span> = Math.min(inext, measureLimit);

         <span class="org-type">ReplacementSpan</span> <span class="org-variable-name">replacement</span> = <span class="org-constant">null</span>;

         <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = 0; j &lt; mMetricAffectingSpanSpanSet.<span class="org-type">numberOfSpans</span>; j++) {
             <span class="org-comment-delimiter">// </span><span class="org-comment">Both intervals [spanStarts..spanEnds] and [mStart + i..mStart + mlimit] are NOT</span>
             <span class="org-comment-delimiter">// </span><span class="org-comment">empty by construction. This special case in getSpans() explains the &gt;= &amp; &lt;= tests</span>
             <span class="org-keyword">if</span> ((mMetricAffectingSpanSpanSet.spanStarts[j] &gt;= mStart + mlimit) ||
                     (mMetricAffectingSpanSpanSet.spanEnds[j] &lt;= mStart + i)) <span class="org-keyword">continue</span>;
             <span class="org-keyword">final</span> <span class="org-type">MetricAffectingSpan</span> <span class="org-variable-name">span</span> = mMetricAffectingSpanSpanSet.spans[j];
             <span class="org-keyword">if</span> (span <span class="org-keyword">instanceof</span> ReplacementSpan) {
                 replacement = (<span class="org-type">ReplacementSpan</span>)span;
             } <span class="org-keyword">else</span> {
                 <span class="org-comment-delimiter">// </span><span class="org-comment">We might have a replacement that uses the draw</span>
                 <span class="org-comment-delimiter">// </span><span class="org-comment">state, otherwise measure state would suffice.</span>
                 span.updateDrawState(wp);
             }
         }

         <span class="org-keyword">if</span> (replacement != <span class="org-constant">null</span>) {
             x += handleReplacement(replacement, wp, i, mlimit, runIsRtl, c, x, top, y,
                     bottom, fmi, needWidth || mlimit &lt; <span class="org-type">measureLimit</span>);
             <span class="org-keyword">continue</span>;
         }

         <span class="org-keyword">final</span> <span class="org-type">TextPaint</span> <span class="org-variable-name">activePaint</span> = mActivePaint;
         activePaint.set(mPaint);
         <span class="org-type">int</span> <span class="org-variable-name">activeStart</span> = i;
         <span class="org-type">int</span> <span class="org-variable-name">activeEnd</span> = mlimit;
         <span class="org-keyword">final</span> <span class="org-type">DecorationInfo</span> <span class="org-variable-name">decorationInfo</span> = mDecorationInfo;
         mDecorations.clear();
         <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">j</span> = i, <span class="org-variable-name">jnext</span>; j &lt; <span class="org-type">mlimit</span>; j = jnext) {
             jnext = mCharacterStyleSpanSet.getNextTransition(mStart + j, mStart + inext) -
                     mStart;

             <span class="org-keyword">final</span> <span class="org-type">int</span> <span class="org-variable-name">offset</span> = Math.min(jnext, mlimit);
             wp.set(mPaint);
             <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">k</span> = 0; k &lt; mCharacterStyleSpanSet.<span class="org-type">numberOfSpans</span>; k++) {
                 <span class="org-comment-delimiter">// </span><span class="org-comment">Intentionally using &gt;= and &lt;= as explained above</span>
                 <span class="org-keyword">if</span> ((mCharacterStyleSpanSet.spanStarts[k] &gt;= mStart + offset) ||
                         (mCharacterStyleSpanSet.spanEnds[k] &lt;= mStart + j)) <span class="org-keyword">continue</span>;

                 <span class="org-keyword">final</span> <span class="org-type">CharacterStyle</span> <span class="org-variable-name">span</span> = mCharacterStyleSpanSet.spans[k];
                 span.updateDrawState(wp);
             }

             extractDecorationInfo(wp, decorationInfo);

             <span class="org-keyword">if</span> (j == i) {
                 <span class="org-comment-delimiter">// </span><span class="org-comment">First chunk of text. We can't handle it yet, since we may need to merge it</span>
                 <span class="org-comment-delimiter">// </span><span class="org-comment">with the next chunk. So we just save the TextPaint for future comparisons</span>
                 <span class="org-comment-delimiter">// </span><span class="org-comment">and use.</span>
                 activePaint.set(wp);
             } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>wp.hasEqualAttributes(activePaint)) {
                 <span class="org-comment-delimiter">// </span><span class="org-comment">The style of the present chunk of text is substantially different from the</span>
                 <span class="org-comment-delimiter">// </span><span class="org-comment">style of the previous chunk. We need to handle the active piece of text</span>
                 <span class="org-comment-delimiter">// </span><span class="org-comment">and restart with the present chunk.</span>
                 activePaint.setHyphenEdit(adjustHyphenEdit(
                         activeStart, activeEnd, mPaint.getHyphenEdit()));
                 x += handleText(activePaint, activeStart, activeEnd, i, inext, runIsRtl, c, x,
                         top, y, bottom, fmi, needWidth || activeEnd &lt; <span class="org-type">measureLimit</span>,
                         Math.<span class="org-type">min</span>(activeEnd, mlimit), <span class="org-type">mDecorations</span>);

                 activeStart = j;
                 activePaint.set(wp);
                 mDecorations.clear();
             } <span class="org-keyword">else</span> {
                 <span class="org-comment-delimiter">// </span><span class="org-comment">The present TextPaint is substantially equal to the last TextPaint except</span>
                 <span class="org-comment-delimiter">// </span><span class="org-comment">perhaps for decorations. We just need to expand the active piece of text to</span>
                 <span class="org-comment-delimiter">// </span><span class="org-comment">include the present chunk, which we always do anyway. We don't need to save</span>
                 <span class="org-comment-delimiter">// </span><span class="org-comment">wp to activePaint, since they are already equal.</span>
             }

             activeEnd = jnext;
             <span class="org-keyword">if</span> (decorationInfo.hasDecoration()) {
                 <span class="org-keyword">final</span> <span class="org-type">DecorationInfo</span> <span class="org-variable-name">copy</span> = decorationInfo.copyInfo();
                 copy.start = j;
                 copy.end = jnext;
                 mDecorations.add(copy);
             }
         }
         <span class="org-comment-delimiter">// </span><span class="org-comment">Handle the final piece of text.</span>
         activePaint.setHyphenEdit(adjustHyphenEdit(
                 activeStart, activeEnd, mPaint.getHyphenEdit()));
         x += handleText(activePaint, activeStart, activeEnd, i, inext, runIsRtl, c, x,
                 top, y, bottom, fmi, needWidth || activeEnd &lt; <span class="org-type">measureLimit</span>,
                 Math.<span class="org-type">min</span>(activeEnd, mlimit), <span class="org-type">mDecorations</span>);
     }

     <span class="org-keyword">return</span> x - originalX;
 }
</pre>
</div>
<p>
上述代码有几个关键点：
</p>
<ol class="org-ol">
<li>span只是在updateDrawState()，即改变画笔，最终的绘制还是canvas自己绘制。
</li>
<li>可以看到TextView处理的span的类型和顺序，只有下面两种
<ul class="org-ul">
<li>MetricAffectingSpan
<pre class="example">
The classes that affect character-level text formatting in a way that changes the width or height of characters extend this class.
</pre>
<p>
字符级，影响尺寸的span
</p>
</li>
<li>CharacterStyle
</li>
<li>ReplacementSpan
</li>
</ul>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Footnote</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li><a href="http://old.flavienlaurent.com/blog/2014/01/31/spans/">http://old.flavienlaurent.com/blog/2014/01/31/spans/</a>
</li>
<li><a href="https://medium.com/androiddevelopers/spantastic-text-styling-with-spans-17b0c16b4568">https://medium.com/androiddevelopers/spantastic-text-styling-with-spans-17b0c16b4568</a>
</li>
<li><a href="https://blog.csdn.net/u012422440/article/details/52155924">https://blog.csdn.net/u012422440/article/details/52155924</a>
</li>
<li><a href="http://jinjian.info/2017/08/06/TextView%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%AF%87/">http://jinjian.info/2017/08/06/TextView%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E7%AF%87/</a>
</li>
<li><a href="https://jaeger.itscoder.com/android/2016/08/05/staticlayout-source-analyse.html">https://jaeger.itscoder.com/android/2016/08/05/staticlayout-source-analyse.html</a>
</li>
<li><a href="https://www.cnblogs.com/bvin/p/5370490.html">https://www.cnblogs.com/bvin/p/5370490.html</a>
</li>
<li><a href="http://ragnraok.github.io/textview-pre-render-research.html">http://ragnraok.github.io/textview-pre-render-research.html</a>
</li>
<li><a href="https://blog.csdn.net/kl794756707/article/details/52014688">https://blog.csdn.net/kl794756707/article/details/52014688</a>
</li>
</ul>
</div>
</div>

  </div><!-- /.entry-content -->
  <footer class="post-info-footer">
        Category: <a href="http://www.iknockdoor.com/category/kai-fa.html"><span>开发</span></a>
    
        Tags:
            <a href="http://www.iknockdoor.com/tag/android.html"><span>Android</span></a>
    
  </footer>
</section>
        </div>
        <footer id="contentinfo" class="body">
          © 2017-2020 iknockdoor</address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>