<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>java中的闭包和匿名内部类</title>
<!--  -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta name='viewport' content='width=device-width,initial-scale=1'><link rel='stylesheet' href='/res/code.css' /><link rel='stylesheet' href='/res/solarized-light.min.css' />
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://www.iknockdoor.com/"> UP </a>
|
 <a accesskey="H" href="http://www.iknockdoor.com/"> HOME </a>
|
<a accesskey="H" href=""> RSS </a>
</div><div id="content">
<h1 class="title">java中的闭包和匿名内部类</h1>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">java中匿名内部类使用外部方法的参数或局部变量的场景</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">

<pre class="src src-java">  <span class="org-keyword">interface</span> <span class="org-type">AnnoInner</span>(){addXYZ();}
<span class="org-keyword">public</span> <span class="org-keyword">class</span> <span class="org-type">Outer</span> {
    <span class="org-keyword">public</span> <span class="org-type">AnnoInner</span> <span class="org-function-name">getAnnoInner</span>(<span class="org-keyword">final</span> <span class="org-type">int</span> <span class="org-variable-name">x</span>){
        <span class="org-keyword">final</span> <span class="org-type">int</span> <span class="org-variable-name">y</span>=100;
        <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">AnnoInner</span>(){
            <span class="org-type">int</span> <span class="org-variable-name">z</span>=100;
            <span class="org-keyword">public</span> <span class="org-type">int</span> <span class="org-function-name">addXYZ</span>(){<span class="org-keyword">return</span> x+y+z;}
            <span class="org-comment-delimiter">//</span><span class="org-comment">public void changeY(){y+=1;}    //&#36825;&#20010;&#20989;&#25968;&#26080;&#27861;&#20462;&#25913;&#22806;&#37096;&#29615;&#22659;&#20013;&#30340;&#33258;&#30001;&#21464;&#37327;y&#12290;</span>
        };
    }
    <span class="org-keyword">private</span> <span class="org-type">int</span> <span class="org-variable-name">num</span>=100;
}
</pre>
</div>
<p>
上面这段代码匿名内部类的addXYZ()函数却直接使用了x和y这两个自由变量来计算结果。这就说明，外部方法getAnnoInner()事实上已经对内部类
AnnoInner构成了一个闭包。但这里别扭的地方是这两个x和y都必须用final修饰。
</p>

<p>
这是为什么呢？因为这里Java编译器支持了闭包，但支持地不完整。说支持了闭包，是因为编译器编译的时候其实悄悄对函数做了手脚，偷偷把外部环境方法的x和y局部变量，拷贝了一份到匿名内部类里。如下面的代码所示。
</p>

<div class="org-src-container">

<pre class="src src-java"><span class="org-keyword">interface</span> <span class="org-type">AnnoInner</span>(){addXYZ();}
<span class="org-keyword">public</span> <span class="org-keyword">class</span> <span class="org-type">Outer</span> {
    <span class="org-keyword">public</span> <span class="org-type">AnnoInner</span> <span class="org-function-name">getAnnoInner</span>(<span class="org-keyword">final</span> <span class="org-type">int</span> <span class="org-variable-name">x</span>){
        <span class="org-keyword">final</span> <span class="org-type">int</span> <span class="org-variable-name">y</span>=100;
        <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">AnnoInner</span>(){
            <span class="org-type">int</span> <span class="org-variable-name">copyX</span>=x;    <span class="org-comment-delimiter">//</span><span class="org-comment">&#32534;&#35793;&#22120;&#30456;&#24403;&#20110;&#25335;&#36125;&#20102;&#22806;&#37096;&#33258;&#30001;&#21464;&#37327;x&#30340;&#19968;&#20010;&#21103;&#26412;&#21040;&#21311;&#21517;&#20869;&#37096;&#31867;&#37324;&#12290;</span>
            <span class="org-type">int</span> <span class="org-variable-name">copyY</span>=y;    <span class="org-comment-delimiter">//</span><span class="org-comment">&#32534;&#35793;&#22120;&#30456;&#24403;&#20110;&#25335;&#36125;&#20102;&#22806;&#37096;&#33258;&#30001;&#21464;&#37327;y&#30340;&#19968;&#20010;&#21103;&#26412;&#21040;&#21311;&#21517;&#20869;&#37096;&#31867;&#37324;&#12290;</span>
            <span class="org-type">int</span> <span class="org-variable-name">z</span>=100;
            <span class="org-keyword">public</span> <span class="org-type">int</span> <span class="org-function-name">addXYZ</span>(){<span class="org-keyword">return</span> x+y+z;}
            <span class="org-comment-delimiter">//</span><span class="org-comment">public void changeY(){y+=1;}    //&#36825;&#20010;&#20989;&#25968;&#26080;&#27861;&#20462;&#25913;&#22806;&#37096;&#29615;&#22659;&#20013;&#30340;&#33258;&#30001;&#21464;&#37327;y&#12290;</span>
        };
    }

    <span class="org-keyword">private</span> <span class="org-type">int</span> <span class="org-variable-name">num</span>=100;
}
</pre>
</div>
<p>
所以用R大回答里的原话说就是：
</p>
<pre class="example">
Java编译器实现的只是capture-by-value，并没有实现capture-by-reference。
</pre>
<p>
而只有后者才能保持匿名内部类和外部环境局部变量保持同步。但Java又不肯明说，只能粗暴地一刀切，就说既然内外不能同步，那就不许大家改外围的局部变量。
</p>

<p>
这就解释了两个问题：
</p>
<ol class="org-ol">
<li>为什么匿名内部类能够访问外部方法的参数或者局部变量
</li>
<li>为什么被匿名内部类访问的外部方法的参数或局部变量必须是final的
</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">

<div id="org-div-home-and-up">
 <a href="/index.html"> 返回目录 </a>
</div>
<p class="author">by chappie (iknockdoor.com@gmail.com)</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.2.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-103057848-1', 'auto');
        ga('send', 'pageview');
</script>
</div>
</body>
</html>
