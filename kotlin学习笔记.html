<!DOCTYPE html>
<html lang="zh_cn">
<head>
        <title>iknockdoor-kotlin学习笔记</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" type="text/css" href="http://www.iknockdoor.com/theme/css/org.css" />
        <link rel="stylesheet" type="text/css" href="http://www.iknockdoor.com/theme/css/custom.css" />
        <link href="http://www.iknockdoor.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="iknockdoor Full Atom Feed" />

    <meta name="tags" content="kotlin" />

<script>var _gaq=[['_setAccount','UA-103057848-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script>
        <!-- mathjax config similar to math.stackexchange -->
	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
	  jax: ["input/TeX", "output/HTML-CSS"],
	  tex2jax: {
	  inlineMath: [ ['$', '$'] ],
	  displayMath: [ ['$$', '$$']],
	  processEscapes: true,
	  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
	  },
	  messageStyle: "none",
	  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
	  });
	</script>
</head>

<body id="index" class="home">
  <div id="banner"><div id="banner-inside">
      <nav id="menu">
      <header id="site_name">
                iknockdoor
        </header><!-- /#banner -->
          <ul>
            <li><a href="http://www.iknockdoor.com/index.html">Index</a></li>
            <li><a href="http://www.iknockdoor.com/categories.html">Categories</a></li>
            <li><a href="http://www.iknockdoor.com/tags.html">Tags</a></li>
            <li><a href="http://www.iknockdoor.com/archives.html">Archives</a></li>
      </ul></nav><!-- /#menu -->
  </div></div>
  <div id="content">
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="http://www.iknockdoor.com/kotlin学习笔记.html" rel="bookmark"
         title="Permalink to kotlin学习笔记">kotlin学习笔记</a></h2>
 
  </header>
  <footer class="post-info">
    <time class="published" datetime="2019-07-31T00:00:00+08:00">
      2019.07.31 星期三
    </time>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 函数式和面向对象</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>头等函数
</li>
<li>不可变性
</li>
<li>无副作用
</li>
</ul>
<p>
书上提到的函数式编程的三个核心概念。很多人，包括我在内，从真正开始接触开发，基本上都是学习的面向对象的思想，对思考方式影响还是很大，因此对kotlin的学习很大程度上也是想要学习这一个基本的编程思维的转变，从面向对象到函数式，并不是说使用kotlin就必须函数式编程，只是如果用了
kotlin但是不做函数式开发，那么收益就会大打折扣了，kotlin不只是Google
推荐的Android平台的开发语言，而且通过kotlin掌握了函数式开发的思维方式，后面对python，swift都有很大帮助，这也是学习kotlin的目的。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> kotlin的小工具</h2>
<div class="outline-text-2" id="text-2">
<p>
这里说两个点：
</p>
<ol class="org-ol">
<li>编译kotlin代码。和java一样，也是编译成字节码，但在打包时需要将
kotlin运行时包含进来，其实就是kotlin的一些标准库以及对JavaAPI的扩展。
</li>
<li>kotlin也有交互式shell（REPL），这是很多动态语言才有的，很方便，可以充分利用。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 类型推导</h2>
<div class="outline-text-2" id="text-3">
<p>
kotlin中，包括变量声明，函数签名的声明等，只要能够做类型推导的地方基本上都是可以省略类型声明的。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 变量与属性</h2>
<div class="outline-text-2" id="text-4">
<ol class="org-ol">
<li>val和var变量，val相当于final的，var就是普通的Java变量
</li>
<li>属性的声明用的关键字和变量是一样的，但属性是对象的概念，不只包含变量本身，而且包含了对变量的访问器，合起来称为属性。
</li>
<li>顶层属性。顶层属性应该就相当于顶层函数所在类中的静态字段，注意他是属性，所以也会有getter和setter方法，如果直接以常量暴露给Java，可以用const修饰，相当于：
<pre class="example">
public static final String XXX = "" (const val XXX = "")
</pre>
</li>
<li>代码块和函数题中声明的变量默认值？
</li>
<li>属性的初始化问题
<ol class="org-ol">
<li>val的属性必须声明时初始化
</li>
<li>var的属性可以lateinit
</li>
<li>by lazy
</li>
<li>属性，init block初始化顺序，在init block初始化的属性和在声明时初始化效果是一样的，不需要加lateinit
</li>
</ol>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 基本语法</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 语句和表达式</h3>
<div class="outline-text-3" id="text-5-1">
<p>
语句和表达式的区别在于，表达式有值，并且能够作为另一个表达式的一部分使用；而语句只是一种语法结构。在Java中，所有的控制结构都是语句。在
Kotlin中除了循环（for,while,do/while）以外大多数控制结构都是表达式。另一方面，Java中赋值操作是表达式，而在kotlin中反而变成了语句。
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 表达式函数体</h3>
<div class="outline-text-3" id="text-5-2">
<p>
如果一个函数的函数体是由单个表达式构成的，可以用这个表达式作为完整的函数体，省略掉花括号和return语句，这称为/*表达式体*/语法。
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> 中缀调用与解构声明</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>中缀调用就是对于只有一个参数的函数，比如1.to("one")可以写成如下形式：
<pre class="example">
1 to "one"
</pre>
</li>
<li>解构声明就是一次初始化多个变量。原理是约定，使用了componentN()函数
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 可变参数与展开运算符</h3>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> 异常处理</h3>
<div class="outline-text-3" id="text-5-5">
<p>
Kotlin中的异常在实际使用过程中很是别扭，尤其是在io类的时候，Kotlin
的库做了各种封装，而且文档上也不说明什么时候有异常，什么时候没异常，会有什么异常，导致想要处理都不知道需不需要处理异常，处理什么异常。
</p>

<p>
而且kotlin的io封装带来的另一个问题是，你不知道是否需要关闭流对象了。有的自动关闭，有的时候又不自动关闭。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 代码组织方式与访问限制</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 包</h3>
<div class="outline-text-3" id="text-6-1">
<p>
kotlin中的包没有什么其他作用，只是作为命名空间使用
</p>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 源码文件</h3>
<div class="outline-text-3" id="text-6-2">
<ol class="org-ol">
<li>文件名可以随意了，不用像Java必须是类名
</li>
<li>文件的组织也无需按照包结构，但保持包结构是一个良好的习惯
</li>
<li>一个文件可以包含多个类，也可以直接包含函数
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> kotlin中的可见性修饰</h3>
<div class="outline-text-3" id="text-6-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">修饰符</td>
<td class="left">类成员</td>
<td class="left">顶层声明</td>
</tr>

<tr>
<td class="left">public(默认)</td>
<td class="left">所有地方可见</td>
<td class="left">所有地方可见</td>
</tr>

<tr>
<td class="left">internal</td>
<td class="left">模块中可见</td>
<td class="left">模块中可见</td>
</tr>

<tr>
<td class="left">protected</td>
<td class="left">子类中可见</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">private</td>
<td class="left">类中可见</td>
<td class="left">文件中可见</td>
</tr>
</tbody>
</table>
<pre class="example">
所谓一个模块是指一起参与编译的一组文件
kotlin和Java的protected也是不一样的，kotlin中的protected只能在类和他的子类中访问
</pre>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> 嵌套类和内部类</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>kotlin中的，在类中声明的类默认嵌套类，即相当于Java中的静态内部类
</li>
<li>kotlin中如果声明持有外部类引用的内部类，需要用inner关键字
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> 密封类</h3>
<div class="outline-text-3" id="text-6-5">
<p>
这块书上其实也没讲太清楚，大概意思是说用sealed关键字声明的类默认是
open的，但是他的直接子类必须嵌套在父类中。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 与Java互操作</h2>
<div class="outline-text-2" id="text-7">
<ol class="org-ol">
<li>.javaClass
</li>
<li>函数命名参数和默认值 @JvmOverloads
</li>
<li>属性的getter和setter
</li>
<li>顶层函数的如何在Java中调用？顶层函数都会编译成为所声明的包下的
JoinKt类的静态方法。也可以通过@JvmName注解指定生成包含顶层函数的类的名字。
</li>
<li>带有默认实现的接口，默认实现也是通过静态方法实现的
</li>
<li>lambda与函数式接口
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 扩展函数，局部函数和扩展属性</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 扩展函数的声明</h3>
<div class="outline-text-3" id="text-8-1">
<pre class="example">
fun String.lastChar():Char = get(length - 1)
</pre>
<p>
挺简单的，只有接收者类型是必须的，接收者对象this是可以省略的，上面就省略了this
</p>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> <span class="todo TODO">TODO</span> 扩展函数的声明位置和有效范围</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>目前书上看到的例子是在顶层做的声明，是否可以在类的内部声明呢？
<ul class="org-ul">
<li>可以在方法内声明
</li>
</ul>
</li>
<li>有效范围应该是包范围，遵循import导入语法，不会在整个项目范围内生效
</li>
<li>为了避免函数名冲突，可以通过as关键字重命名，如:
<pre class="example">
import strings.lastChar as last
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> 扩展函数的本质与Java的互操作</h3>
<div class="outline-text-3" id="text-8-3">
<p>
其实就是个类的静态方法，将接受者对象作为了第一个参数。这个类是自动生成的，类名是声明函数的文件名决定的。所以扩展函数无非就是静态函数的一个高效语法糖。准确的说，kotlin就是Java的一个语法糖。
</p>
</div>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> 扩展函数需要注意的点</h3>
<div class="outline-text-3" id="text-8-4">
<ol class="org-ol">
<li>由于实现原理的原因，扩展函数并不具备多态性
</li>
<li>如果成员函数与扩展函数有相同的签名，会优先使用成员函数。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5"><span class="section-number-3">8.5</span> 扩展属性</h3>
<div class="outline-text-3" id="text-8-5">
<p>
扩展属性只是一种语法，本质也是一个静态函数，而且没有支持字段，并不可能真的给已有的Java对象增加属性。
</p>
</div>
</div>
<div id="outline-container-sec-8-6" class="outline-3">
<h3 id="sec-8-6"><span class="section-number-3">8.6</span> 局部函数和扩展函数是有点像的，感觉低层实现原理应该也是一样的</h3>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> kotlin的面向对象</h2>
<div class="outline-text-2" id="text-9">
<ol class="org-ol">
<li>重载或者实现接口，抽象类的抽象方法，必须使用override关键字
</li>
<li>接口方法可以有默认实现
</li>
<li>类和方法都是默认final的，如果可被继承或可被重写，需要显式的声明
open，被重写的类或者方法默认是open的，但可以通过主动声明成final的
</li>
<li>数据类，就是默认给提供了equals啊，hashcode啊，toString啊等模版式的实现
</li>
<li>类委托
</li>
<li>object关键字
<ol class="org-ol">
<li>对象声明
<ol class="org-ol">
<li>把class关键词换成object就可以了
</li>
<li>另外一个区别是没有构造方法，由于是单例，并不需要
</li>
</ol>
</li>
<li>伴生对象伴生对象需要先说明为什么要有伴生对象。kotlin中没有static关键字，那么Java中的static方法的用法要怎么实现呢？kotlin大部分情况是通过顶层函数做这个事儿的，但是顶层函数又无法访问类内部的private
方法和成员，这个时候就需要伴生对象了，伴生对象也不是什么新的专门为这事儿创建的语法，而是因为对象声明的实现本来就是类用静态成员，刚刚好满足这个需求。伴生对象的语法:
<div class="org-src-container">

<pre class="src src-kotlin">	class A {
companion object {
fun bar(){
...
}
}
}
</pre>
</div>
</li>
<li>对象表达式
</li>
<li>匿名内部类
</li>
<li>单例
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> 类的声明</h3>
<div class="outline-text-3" id="text-9-1">
<p>
主构造方法和从构造方法可以同时存在吗？可以，但是从构造方法必须调用主构造方法。从构造方法如何初始化属性？
</p>
<div class="org-src-container">

<pre class="src src-kotlin">   class User //:最简单的，构造方法不带参数使用默认构造方法
   open class User(val name:String)//:带参数主构造方法
   class User constructor(_name:string){
       val name:String
       init{
	   name = _name
       }
   }
   class FBUser(name:String):User(name){...}//:初始化父类
   open class Button
   class RadioButton:Button()//:必须显示的调用父类的默认构造方法，如果父类是接口就不需要了
   class View{//:无主构造方法，两个从构造方法
   constructor(ctx:Context){}
   constructor(ctx:Context, attr:AttributeSet){}
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 函数式编程</h2>
<div class="outline-text-2" id="text-10">
<ol class="org-ol">
<li>lambda表达式
<pre class="example">
{x: Int,y: Int -&gt; x+y}
</pre>
</li>
<li>函数类型声明，一个变量可以是函数类型的
<pre class="example">
(Int,Int) -&gt; Int
</pre>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 类型系统与空保护</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li>安全调用运算符 ?.(foo?.bar())
<ul class="org-ul">
<li>foo != null -&gt; foo.bar()
</li>
<li>foo == null -&gt; null
</li>
</ul>
</li>
<li>Elvis 运算符 ?: (foo ?: bar)
<ul class="org-ul">
<li>foo != null -&gt; foo
</li>
<li>foo == null -&gt; bar
</li>
</ul>
</li>
<li>安全转换 as? (foo as? Type)
<ul class="org-ul">
<li>foo is Type -&gt; foo as Type
</li>
<li>foo !is Type -&gt; null
</li>
</ul>
</li>
<li>非空断言 !! (foo!!)
<ul class="org-ul">
<li>foo != null -&gt; foo
</li>
<li>foo == null -&gt; NullPointerException
</li>
</ul>
</li>
<li>let表达式 (foo?.let{..it ..})
<ul class="org-ul">
<li>foo != null -&gt; 在lambda内部it是非空的
</li>
<li>foo == null -&gt; 什么都不会发生
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> 实际开发中遇到的蛋疼的问题</h3>
<div class="outline-text-3" id="text-11-1">
<div class="org-src-container">

<pre class="src src-kotlin">class Some(){
var s:XXX?=null
fun f(){
if(s != null){s...}//:编译不过，提示s是var，可能改变，无法进行智能转换
s?.let{it...}//:编译可以。。。这是为什么？
}
}
</pre>
</div>
<p>
可以通过安全类型转换之后赋值给一个val的变量，然后这个变量就可以正常使用了，let函数的语法应该也是内部it是个val的
</p>
</div>
<div id="outline-container-sec-11-1-1" class="outline-4">
<h4 id="sec-11-1-1"><span class="section-number-4">11.1.1</span> 异常处理</h4>
<div class="outline-text-4" id="text-11-1-1">
<p>
根本不知道会不会发生异常，而且标准库文档也没有说明，比如IO库，那都不知道有没有异常，怎么用？？？全靠测试？
</p>
</div>
</div>
<div id="outline-container-sec-11-1-2" class="outline-4">
<h4 id="sec-11-1-2"><span class="section-number-4">11.1.2</span> 构造函数的getter和setter</h4>
<div class="outline-text-4" id="text-11-1-2">
<p>
如果你的一个属性外部能读，但不能写，这个时候你就没办法使用构造函数的语法，你就得老老实实的写private的setter，代码量一点也不必java少，而且还很难看
</p>
</div>
</div>
<div id="outline-container-sec-11-1-3" class="outline-4">
<h4 id="sec-11-1-3"><span class="section-number-4">11.1.3</span> 增加包大小</h4>
</div>
<div id="outline-container-sec-11-1-4" class="outline-4">
<h4 id="sec-11-1-4"><span class="section-number-4">11.1.4</span> mockito,junit4，还会遇到其他库对kotlin不支持的</h4>
</div>
<div id="outline-container-sec-11-1-5" class="outline-4">
<h4 id="sec-11-1-5"><span class="section-number-4">11.1.5</span> 默认final，mockito-android都不支持</h4>
</div>
<div id="outline-container-sec-11-1-6" class="outline-4">
<h4 id="sec-11-1-6"><span class="section-number-4">11.1.6</span> 事实证明，同样功能的代码java写出来比kotlin整洁，并不是因为看习惯了</h4>
</div>
<div id="outline-container-sec-11-1-7" class="outline-4">
<h4 id="sec-11-1-7"><span class="section-number-4">11.1.7</span> java中几乎看不到对属性的引用，都是调用方法，也可以称为发消息</h4>
<div class="outline-text-4" id="text-11-1-7">
<p>
kotlin就乱了，有些地方是调用方法，有些地方是引用属性，很乱，毫无原则，面向对象本就应该只调用方法的，kotlin可能想面向函数编程，但又无法完全面向函数编程。
</p>
</div>
</div>
<div id="outline-container-sec-11-1-8" class="outline-4">
<h4 id="sec-11-1-8"><span class="section-number-4">11.1.8</span> 传说中的与java的互操作性</h4>
<div class="outline-text-4" id="text-11-1-8">
<p>
你试着在kotlin的类或者接口中声明一个能抛异常的方法，你无法声明，那么当你用java实现kotlin中定义的接口时问题就来了，java这个实现方法中不处理异常，这很正常，异常一般要在最上层处理，所以要抛出，但是
kotlin声明的接口却无法抛出，你无法改变方法签名，最后你只能在内部处理异常，但可能又没有能力处理，比如需要界面显示，这个时候异常就断了，埋下了坑。
</p>

<p>
你在kotlin中声明一个方法名为new的方法，你在java中根本无法调用，这是个关键字。
</p>

<p>
还有其他情况，比如静态函数引用，lambda表达式，很奇怪，Android都不支持java8的一些特性，kotlin居然支持了，其实只是语法糖，kotlin内部转化为常规的java写法，而且还不是java8的，这样效率可想而知。另外这些东西直接导致java无法调用kotlin，只能kotlin调用Android，kotlin的互操作性是单向的。
</p>
</div>
</div>
<div id="outline-container-sec-11-1-9" class="outline-4">
<h4 id="sec-11-1-9"><span class="section-number-4">11.1.9</span> 其他语言也有没有异常的，为什么kotlin就不行</h4>
<div class="outline-text-4" id="text-11-1-9">
<p>
没有异常得又返回值啊，像C总会给一个错误码，至少还有处理的机会，
kotlin就有意思了，因为兼容java的异常，能够抛出异常，所以遇到错误时没有返回码，但是却不知道会抛出什么异常，文档上也没有，你只能等着崩溃了
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> <span class="todo TODO">TODO</span> 依赖注入的问题</h2>
<div class="outline-text-2" id="text-12">
<p>
在Java中存在这样的一个问题，类的功能依赖于其他类，其他类的对象需要在类的该类的方法调用前就被初始化。比如类A的实现依赖类B，在调用A的方法前需要已经有B的实例了，但是由于A存在一些框架内，比如A是Android的一个自定义view，如果可以被规范的xml inflate出来，需要A的构造方法满足一定范式，这样的话我们就无法在A构造时给出B的实例，只能通过在A中增加方法来注入B的实例，但缺点时我们无法保证注入的方法的调用顺序，这就是一个依赖注入的问题，看看kotlin中是否有解决办法。
</p>

<p>
事实上构造方法不应该用来做依赖注入，而是应该专注类自身的配置初始化。
</p>
<pre class="example">
果然，在看到类型系统一章时找到了解决方法，而且是语言级的很好。使用延迟初始化的属性，关键字lateinit
</pre>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> <span class="todo TODO">TODO</span> 修改函数的能力</h2>
<div class="outline-text-2" id="text-13">
<p>
之前在学习lisp时有个功能是可以给已有的函数增加在执行前执行的代码，或增加在执行后执行的代码，一直觉得这个功能很强大也很有用，但在用Java的时候就有点麻烦。例如以下的例子
</p>
<div class="org-src-container">

<pre class="src src-java">  <span class="org-keyword">class</span> <span class="org-type">A</span>{
<span class="org-type">void</span> <span class="org-function-name">f</span>(){}
}
<span class="org-keyword">class</span> B <span class="org-type">extend</span> <span class="org-type">A</span>{
  <span class="org-type">void</span> <span class="org-function-name">f</span>(){
<span class="org-keyword">super</span>.f()<span class="org-comment-delimiter">//</span><span class="org-comment">:&#36825;&#31181;&#32487;&#25215;&#20851;&#31995;&#65292;&#24076;&#26395;B&#30340;f&#26041;&#27861;&#35843;&#29992;&#26102;&#21487;&#20197;&#40664;&#35748;&#35843;&#29992;&#21040;A&#65292;&#21482;&#33021;&#36890;&#36807;super&#36825;&#31181;&#26041;&#24335;&#35843;&#29992;&#65292;&#20294;&#26159;&#21448;&#26080;&#27861;&#24378;&#21046;&#65292;&#24456;&#23481;&#26131;&#34987;&#24536;&#35760;</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">...</span>
}
}
<span class="org-comment-delimiter">//</span><span class="org-comment">&#65306;&#21478;&#22806;&#19968;&#31181;&#22788;&#29702;&#30340;&#36825;&#31181;&#38656;&#27714;&#30340;&#26041;&#24335;&#26159;&#22312;&#29238;&#31867;&#20013;&#35843;&#29992;&#23376;&#31867;&#30340;&#22238;&#35843;&#20989;&#25968;&#65292;&#20063;&#19981;&#26041;&#20415;&#65292;&#32780;&#19988;&#23376;&#31867;&#30340;&#25509;&#21475;&#20063;&#19981;&#23481;&#26131;&#29702;&#35299;</span>
</pre>
</div>
<p>
除了继承的方式，通过委托的方式也可以实现，不过和通过super的方法调用没什么区别，需要主动调用，而且有感知，我想尽量做到子类无感知，毕竟是子类无需关注的需求。
</p>

<p>
kotlin中是否有比较好的处理方法呢？
</p>
</div>
</div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> 约定与属性委托</h2>
<div class="outline-text-2" id="text-14">
</div><div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1"><span class="section-number-3">14.1</span> 属性委托</h3>
<div class="outline-text-3" id="text-14-1">
<p>
属性委托依赖于约定，根据约定，一个类具有getValue和setValue方法，可以是成员函数也可以是扩展函数，那么他可以做为属性的委托使用，通过by
关键字（注意val的属性的委托不需要setValue方法）。
</p>

<p>
如果只是有个方法约定，那么属性委托就没什么意思了，只是一个简单的语法糖，让kotlin中的属性委托更有用的关键是委托过程中提供了拥有这个属性的对象和一个称为KProperty类型的参数，这个参数可以访问属性名，这样就可以把多个属性委托给同一个委托对象，委托对象可以根据KProperty来做不同的操作，这样确实可以抽象出很多模版代码。
</p>

<p>
系统支持，kotlin标准库中Map和MutableMap接口都定义了符合委托约定的函数，因此可以直接用。很多框架也支持，这样就更方便一些。
</p>

<p>
实际使用中也还是有不少问题，能够直接将属性的名字做为key的能力相当于可以读取和使用属性程序代码引用的字面值，这可不是程序中的字符串，或者说程序有数据段和代码段的区分，这就相当于把代码段的内容当数据段使用，带来的问题也很明确，你只能用通过属性访问的方式读取和设置数据，其他对map中key的操作，比如比较，那就会出问题了，尤其是存在代码混淆的时候，不过这个倒也是可以解决，通过位置对照表转换成自己想要的字符串。
</p>
</div>
</div>
</div>

  </div><!-- /.entry-content -->
  <footer class="post-info-footer">
        Category: <a href="http://www.iknockdoor.com/category/kai-fa.html"><span>开发</span></a>
    
        Tags:
            <a href="http://www.iknockdoor.com/tag/kotlin.html"><span>kotlin</span></a>
    
  </footer>
</section>
        </div>
        <footer id="contentinfo" class="body">
          © 2017-2020 iknockdoor</address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>