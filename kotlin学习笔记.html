<!DOCTYPE html>
<html lang="zh_cn">
<head>
        <title>iknockdoor-kotlin学习笔记</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" type="text/css" href="http://www.iknockdoor.com/theme/css/org.css" />
        <link rel="stylesheet" type="text/css" href="http://www.iknockdoor.com/theme/css/custom.css" />
        <link href="http://www.iknockdoor.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="iknockdoor Full Atom Feed" />


<script>var _gaq=[['_setAccount','UA-103057848-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script>
        <!-- mathjax config similar to math.stackexchange -->
	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
	  jax: ["input/TeX", "output/HTML-CSS"],
	  tex2jax: {
	  inlineMath: [ ['$', '$'] ],
	  displayMath: [ ['$$', '$$']],
	  processEscapes: true,
	  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
	  },
	  messageStyle: "none",
	  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
	  });
	</script>
</head>

<body id="index" class="home">
  <div id="banner"><div id="banner-inside">
      <nav id="menu">
      <header id="site_name">
                iknockdoor
        </header><!-- /#banner -->
          <ul>
            <li><a href="http://www.iknockdoor.com/index.html">Index</a></li>
            <li><a href="http://www.iknockdoor.com/categories.html">Categories</a></li>
            <li><a href="http://www.iknockdoor.com/tags.html">Tags</a></li>
            <li><a href="http://www.iknockdoor.com/archives.html">Archives</a></li>
      </ul></nav><!-- /#menu -->
  </div></div>
  <div id="content">
<section id="content" class="body">
  <header>
    <h2 class="entry-title">
      <a href="http://www.iknockdoor.com/kotlin学习笔记.html" rel="bookmark"
         title="Permalink to kotlin学习笔记">kotlin学习笔记</a></h2>
 
  </header>
  <footer class="post-info">
    <time class="published" datetime="2019-07-31T00:00:00+08:00">
      三 31 七月 2019
    </time>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 函数式和面向对象</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>头等函数
</li>
<li>不可变性
</li>
<li>无副作用
</li>
</ul>
<p>
书上提到的函数式编程的三个核心概念。很多人，包括我在内，从真正开始接触开发，基本上都是学习的面向对象的思想，对思考方式影响还是很大，因此对kotlin的学习很大程度上也是想要学习这一个基本的编程思维的转变，从面向对象到函数式，并不是说使用kotlin就必须函数式编程，只是如果用了
kotlin但是不做函数式开发，那么收益就会大打折扣了，kotlin不只是Google
推荐的Android平台的开发语言，而且通过kotlin掌握了函数式开发的思维方式，后面对python，swift都有很大帮助，这也是学习kotlin的目的。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> kotlin的小工具</h2>
<div class="outline-text-2" id="text-2">
<p>
这里说两个点：
</p>
<ol class="org-ol">
<li>编译kotlin代码。和java一样，也是编译成字节码，但在打包时需要将
kotlin运行时包含进来，其实就是kotlin的一些标准库以及对JavaAPI的扩展。
</li>
<li>kotlin也有交互式shell（REPL），这是很多动态语言才有的，很方便，可以充分利用。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 类型推导</h2>
<div class="outline-text-2" id="text-3">
<p>
kotlin中，包括变量声明，函数签名的声明等，只要能够做类型推导的地方基本上都是可以省略类型声明的。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 变量与属性</h2>
<div class="outline-text-2" id="text-4">
<ol class="org-ol">
<li>val和var变量，val相当于final的，var就是普通的Java变量
</li>
<li>属性的声明用的关键字和变量是一样的，但属性是对象的概念，不只包含变量本身，而且包含了对变量的访问器，合起来称为属性。
</li>
<li>顶层属性。顶层属性应该就相当于顶层函数所在类中的静态字段，注意他是属性，所以也会有getter和setter方法，如果直接以常量暴露给Java，可以用const修饰，相当于：
<pre class="example">
public static final String XXX = "" (const val XXX = "")
</pre>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 基本语法</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 语句和表达式</h3>
<div class="outline-text-3" id="text-5-1">
<p>
语句和表达式的区别在于，表达式有值，并且能够作为另一个表达式的一部分使用；而语句只是一种语法结构。在Java中，所有的控制结构都是语句。在
Kotlin中除了循环（for,while,do/while）以外大多数控制结构都是表达式。另一方面，Java中赋值操作是表达式，而在kotlin中反而变成了语句。
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 表达式函数体</h3>
<div class="outline-text-3" id="text-5-2">
<p>
如果一个函数的函数体是由单个表达式构成的，可以用这个表达式作为完整的函数体，省略掉花括号和return语句，这称为/*表达式体*/语法。
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> 中缀调用与解构声明</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>中缀调用就是对于只有一个参数的函数，比如1.to("one")可以写成如下形式：
<pre class="example">
1 to "one"
</pre>
</li>
<li>解构声明就是一次初始化多个变量。原理是约定，使用了componentN()函数
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 可变参数与展开运算符</h3>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 代码组织方式与访问限制</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 包</h3>
<div class="outline-text-3" id="text-6-1">
<p>
kotlin中的包没有什么其他作用，只是作为命名空间使用
</p>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 源码文件</h3>
<div class="outline-text-3" id="text-6-2">
<ol class="org-ol">
<li>文件名可以随意了，不用像Java必须是类名
</li>
<li>文件的组织也无需按照包结构，但保持包结构是一个良好的习惯
</li>
<li>一个文件可以包含多个类，也可以直接包含函数
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> kotlin中的可见性修饰</h3>
<div class="outline-text-3" id="text-6-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">修饰符</td>
<td class="left">类成员</td>
<td class="left">顶层声明</td>
</tr>

<tr>
<td class="left">public(默认)</td>
<td class="left">所有地方可见</td>
<td class="left">所有地方可见</td>
</tr>

<tr>
<td class="left">internal</td>
<td class="left">模块中可见</td>
<td class="left">模块中可见</td>
</tr>

<tr>
<td class="left">protected</td>
<td class="left">子类中可见</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">private</td>
<td class="left">类中可见</td>
<td class="left">文件中可见</td>
</tr>
</tbody>
</table>
<pre class="example">
所谓一个模块是指一起参与编译的一组文件
kotlin和Java的protected也是不一样的，kotlin中的protected只能在类和他的子类中访问
</pre>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> 嵌套类和内部类</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>kotlin中的，在类中声明的类默认嵌套类，即相当于Java中的静态内部类
</li>
<li>kotlin中如果声明持有外部类引用的内部类，需要用inner关键字
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> 密封类</h3>
<div class="outline-text-3" id="text-6-5">
<p>
这块书上其实也没讲太清楚，大概意思是说用sealed关键字声明的类默认是
open的，但是他的直接子类必须嵌套在父类中。
</p>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 与Java互操作</h2>
<div class="outline-text-2" id="text-7">
<ol class="org-ol">
<li>.javaClass
</li>
<li>函数命名参数和默认值 @JvmOverloads
</li>
<li>属性的getter和setter
</li>
<li>顶层函数的如何在Java中调用？顶层函数都会编译成为所声明的包下的
JoinKt类的静态方法。也可以通过@JvmName注解指定生成包含顶层函数的类的名字。
</li>
<li>带有默认实现的接口，默认实现也是通过静态方法实现的
</li>
<li>lambda与函数式接口
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 扩展函数，局部函数和扩展属性</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 扩展函数的声明</h3>
<div class="outline-text-3" id="text-8-1">
<pre class="example">
fun String.lastChar():Char = get(length - 1)
</pre>
<p>
挺简单的，只有接收者类型是必须的，接收者对象this是可以省略的，上面就省略了this
</p>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> <span class="todo TODO">TODO</span> 扩展函数的声明位置和有效范围</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>目前书上看到的例子是在顶层做的声明，是否可以在类的内部声明呢？
<ul class="org-ul">
<li>可以在方法内声明
</li>
</ul>
</li>
<li>有效范围应该是包范围，遵循import导入语法，不会在整个项目范围内生效
</li>
<li>为了避免函数名冲突，可以通过as关键字重命名，如:
<pre class="example">
import strings.lastChar as last
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> 扩展函数的本质与Java的互操作</h3>
<div class="outline-text-3" id="text-8-3">
<p>
其实就是个类的静态方法，将接受者对象作为了第一个参数。这个类是自动生成的，类名是声明函数的文件名决定的。所以扩展函数无非就是静态函数的一个高效语法糖。准确的说，kotlin就是Java的一个语法糖。
</p>
</div>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> 扩展函数需要注意的点</h3>
<div class="outline-text-3" id="text-8-4">
<ol class="org-ol">
<li>由于实现原理的原因，扩展函数并不具备多态性
</li>
<li>如果成员函数与扩展函数有相同的签名，会优先使用成员函数。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5"><span class="section-number-3">8.5</span> 扩展属性</h3>
<div class="outline-text-3" id="text-8-5">
<p>
扩展属性只是一种语法，本质也是一个静态函数，而且没有支持字段，并不可能真的给已有的Java对象增加属性。
</p>
</div>
</div>
<div id="outline-container-sec-8-6" class="outline-3">
<h3 id="sec-8-6"><span class="section-number-3">8.6</span> 局部函数和扩展函数是有点像的，感觉低层实现原理应该也是一样的</h3>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> kotlin的面向对象</h2>
<div class="outline-text-2" id="text-9">
<ol class="org-ol">
<li>重载或者实现接口，抽象类的抽象方法，必须使用override关键字
</li>
<li>接口方法可以有默认实现
</li>
<li>类和方法都是默认final的，如果可被继承或可被重写，需要显式的声明
open，被重写的类或者方法默认是open的，但可以通过主动声明成final的
</li>
<li>数据类，就是默认给提供了equals啊，hashcode啊，toString啊等模版式的实现
</li>
<li>类委托
</li>
<li>object关键字
<ol class="org-ol">
<li>对象声明
<ol class="org-ol">
<li>把class关键词换成object就可以了
</li>
<li>另外一个区别是没有构造方法，由于是单例，并不需要
</li>
</ol>
</li>
<li>伴生对象伴生对象需要先说明为什么要有伴生对象。kotlin中没有static关键字，那么Java中的static方法的用法要怎么实现呢？kotlin大部分情况是通过顶层函数做这个事儿的，但是顶层函数又无法访问类内部的private
方法和成员，这个时候就需要伴生对象了，伴生对象也不是什么新的专门为这事儿创建的语法，而是因为对象声明的实现本来就是类用静态成员，刚刚好满足这个需求。伴生对象的语法:
<div class="org-src-container">

<pre class="src src-kotlin">	class A {
companion object {
fun bar(){
...
}
}
}
</pre>
</div>
</li>
<li>对象表达式
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> 类的声明</h3>
<div class="outline-text-3" id="text-9-1">
<div class="org-src-container">

<pre class="src src-kotlin">   class User //:最简单的，构造方法不带参数使用默认构造方法
   open class User(val name:String)//:带参数主构造方法
   class User constructor(_name:string){
       val name:String
       init{
	   name = _name
       }
   }
   class FBUser(name:String):User(name){...}//:初始化父类
   open class Button
   class RadioButton:Button()//:必须显示的调用父类的默认构造方法，如果父类是接口就不需要了
   class View{//:无主构造方法，两个从构造方法
   constructor(ctx:Context){}
   constructor(ctx:Context, attr:AttributeSet){}
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 函数式编程</h2>
<div class="outline-text-2" id="text-10">
<ol class="org-ol">
<li>lambda表达式
<pre class="example">
{x: Int,y: Int -&gt; x+y}
</pre>
</li>
<li>函数类型声明，一个变量可以是函数类型的
<pre class="example">
(Int,Int) -&gt; Int
</pre>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 类型系统与空保护</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li>安全调用运算符 ?.(foo?.bar())
<ul class="org-ul">
<li>foo != null -&gt; foo.bar()
</li>
<li>foo == null -&gt; null
</li>
</ul>
</li>
<li>Elvis 运算符 ?: (foo ?: bar)
<ul class="org-ul">
<li>foo != null -&gt; foo
</li>
<li>foo == null -&gt; bar
</li>
</ul>
</li>
<li>安全转换 as? (foo as? Type)
<ul class="org-ul">
<li>foo is Type -&gt; foo as Type
</li>
<li>foo !is Type -&gt; null
</li>
</ul>
</li>
<li>非空断言 !! (foo!!)
<ul class="org-ul">
<li>foo != null -&gt; foo
</li>
<li>foo == null -&gt; NullPointerException
</li>
</ul>
</li>
<li>let表达式 (foo?.let{..it ..})
<ul class="org-ul">
<li>foo != null -&gt; 在lambda内部it是非空的
</li>
<li>foo == null -&gt; 什么都不会发生
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> <span class="todo TODO">TODO</span> 依赖注入的问题</h2>
<div class="outline-text-2" id="text-12">
<p>
在Java中存在这样的一个问题，类的功能依赖于其他类，其他类的对象需要在类的该类的方法调用前就被初始化。比如类A的实现依赖类B，在调用A的方法前需要已经有B的实例了，但是由于A存在一些框架内，比如A是Android的一个自定义view，如果可以被规范的xml inflate出来，需要A的构造方法满足一定范式，这样的话我们就无法在A构造时给出B的实例，只能通过在A中增加方法来注入B的实例，但缺点时我们无法保证注入的方法的调用顺序，这就是一个依赖注入的问题，看看kotlin中是否有解决办法。
</p>

<p>
事实上构造方法不应该用来做依赖注入，而是应该专注类自身的配置初始化。
</p>
<pre class="example">
果然，在看到类型系统一章时找到了解决方法，而且是语言级的很好。使用延迟初始化的属性，关键字lateinit
</pre>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> <span class="todo TODO">TODO</span> 修改函数的能力</h2>
<div class="outline-text-2" id="text-13">
<p>
之前在学习lisp时有个功能是可以给已有的函数增加在执行前执行的代码，或增加在执行后执行的代码，一直觉得这个功能很强大也很有用，但在用Java的时候就有点麻烦。例如以下的例子
</p>
<div class="org-src-container">

<pre class="src src-java">  <span class="org-keyword">class</span> <span class="org-type">A</span>{
<span class="org-type">void</span> <span class="org-function-name">f</span>(){}
}
<span class="org-keyword">class</span> B <span class="org-type">extend</span> <span class="org-type">A</span>{
  <span class="org-type">void</span> <span class="org-function-name">f</span>(){
<span class="org-keyword">super</span>.f()<span class="org-comment-delimiter">//</span><span class="org-comment">:&#36825;&#31181;&#32487;&#25215;&#20851;&#31995;&#65292;&#24076;&#26395;B&#30340;f&#26041;&#27861;&#35843;&#29992;&#26102;&#21487;&#20197;&#40664;&#35748;&#35843;&#29992;&#21040;A&#65292;&#21482;&#33021;&#36890;&#36807;super&#36825;&#31181;&#26041;&#24335;&#35843;&#29992;&#65292;&#20294;&#26159;&#21448;&#26080;&#27861;&#24378;&#21046;&#65292;&#24456;&#23481;&#26131;&#34987;&#24536;&#35760;</span>
<span class="org-comment-delimiter">//</span><span class="org-comment">...</span>
}
}
<span class="org-comment-delimiter">//</span><span class="org-comment">&#65306;&#21478;&#22806;&#19968;&#31181;&#22788;&#29702;&#30340;&#36825;&#31181;&#38656;&#27714;&#30340;&#26041;&#24335;&#26159;&#22312;&#29238;&#31867;&#20013;&#35843;&#29992;&#23376;&#31867;&#30340;&#22238;&#35843;&#20989;&#25968;&#65292;&#20063;&#19981;&#26041;&#20415;&#65292;&#32780;&#19988;&#23376;&#31867;&#30340;&#25509;&#21475;&#20063;&#19981;&#23481;&#26131;&#29702;&#35299;</span>
</pre>
</div>
<p>
除了继承的方式，通过委托的方式也可以实现，不过和通过super的方法调用没什么区别，需要主动调用，而且有感知，我想尽量做到子类无感知，毕竟是子类无需关注的需求。
</p>

<p>
kotlin中是否有比较好的处理方法呢？
</p>
</div>
</div>

  </div><!-- /.entry-content -->
  <footer class="post-info-footer">
        Category: <a href="http://www.iknockdoor.com/category/misc.html"><span>misc</span></a>
  </footer>
</section>
        </div>
        <footer id="contentinfo" class="body">
          © 2017-2020 iknockdoor</address><!-- /#about -->
        </footer><!-- /#contentinfo -->
</body>
</html>